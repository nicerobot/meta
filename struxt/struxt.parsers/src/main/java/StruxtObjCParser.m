/** \file
 *  This OBJC source file was generated by $ANTLR version 3.3 Nov 30, 2010 12:45:30
 *
 *     -  From the grammar source file : /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g
 *     -                            On : 2011-04-04 13:36:28
 *     -                for the parser : StruxtObjCParserParser *
 * Editing it, at least manually, is not wise. 
 *
 * ObjC language generator and runtime by Alan Condit, acondit|hereisanat|ipns|dotgoeshere|com.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2010 Alan Condit
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// $ANTLR 3.3 Nov 30, 2010 12:45:30 /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g 2011-04-04 13:36:28

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#import "StruxtObjCParser.h"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


#pragma mark Cyclic DFA implementation start DFA6
@implementation DFA6
const static NSInteger dfa6_eot[13] =
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static NSInteger dfa6_eof[13] =
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static unichar dfa6_min[13] =
    {4,4,0,0,4,5,17,4,17,4,5,17,17};
const static unichar dfa6_max[13] =
    {22,25,0,0,26,26,26,8,26,26,26,26,26};
const static NSInteger dfa6_accept[13] =
    {-1,-1,2,1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static NSInteger dfa6_special[13] =
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static NSInteger dfa6_transition[] = {};
const static NSInteger dfa6_transition0[] = {11, -1, 11, 11, 11, -1, -1, 
 -1, -1, -1, -1, -1, -1, 3, 2, 3, 2, 3, 2, 3, 3, 3, 7};
const static NSInteger dfa6_transition1[] = {3, 1, -1, -1, -1, -1, -1, -1, 
 -1, -1, -1, -1, -1, -1, 2, -1, 2, -1, 2};
const static NSInteger dfa6_transition2[] = {3, 2, 3, 2, 3, 2, 3, 3, 3, 
 7};
const static NSInteger dfa6_transition3[] = {12, -1, -1, -1, -1, -1, -1, 
 -1, -1, -1, -1, -1, 3, 2, 3, 2, 3, 2, 3, 3, 3, 7};
const static NSInteger dfa6_transition4[] = {5, 4, 5, 5, 5, -1, -1, -1, 
 -1, -1, -1, -1, -1, 3, 2, 3, 2, 3, 2, 3, 3, 3};
const static NSInteger dfa6_transition5[] = {8, -1, -1, -1, -1, -1, -1, 
 -1, -1, -1, -1, -1, 3, 2, 3, 2, 3, 2, 3, 3, 3, 7};
const static NSInteger dfa6_transition6[] = {10, 9, 10, 10, 10};
const static NSInteger dfa6_transition7[] = {6, -1, 6, 6, 6, -1, -1, -1, 
 -1, -1, -1, -1, -1, 3, 2, 3, 2, 3, 2, 3, 3, 3, 7};


+ () newDFA6WithRecognizer:(ANTLRBaseRecognizer *)aRecognizer
{
    return [[[DFA6 alloc] initWithRecognizer:aRecognizer] retain];
}

- (id) initWithRecognizer:(ANTLRBaseRecognizer *) theRecognizer
{
    if ((self = [super initWithRecognizer:theRecognizer]) != nil) {
        decisionNumber = 6;
        eot = dfa6_eot;
        eof = dfa6_eof;
        min = dfa6_min;
        max = dfa6_max;
        accept = dfa6_accept;
        special = dfa6_special;
        if (!(transition = calloc(13, sizeof(void*)))) {
            [self release];
            return nil;
        }
        len = 13;
        transition[0] = dfa6_transition1;
        transition[1] = dfa6_transition4;
        transition[2] = dfa6_transition;
        transition[3] = dfa6_transition;
        transition[4] = dfa6_transition7;
        transition[5] = dfa6_transition5;
        transition[6] = dfa6_transition2;
        transition[7] = dfa6_transition6;
        transition[8] = dfa6_transition2;
        transition[9] = dfa6_transition0;
        transition[10] = dfa6_transition3;
        transition[11] = dfa6_transition2;
        transition[12] = dfa6_transition2;
    }
    return self;
}

- (void) dealloc
{
    free(transition);
    [super dealloc];
}

- (NSString *) description
{
    return @"()* loopback of 28:7: ( node )*";
}


@end /* end DFA6 implementation */

#pragma mark Cyclic DFA implementation end DFA6



#pragma mark Bitsets
static ANTLRBitSet *FOLLOW_node_in_struxt26;
static const unsigned long long FOLLOW_node_in_struxt26_data[] = { 0x0000000000000000LL};
static ANTLRBitSet *FOLLOW_EOF_in_struxt28;
static const unsigned long long FOLLOW_EOF_in_struxt28_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_tag_in_node45;
static const unsigned long long FOLLOW_tag_in_node45_data[] = { 0x0000000003AA0000LL};
static ANTLRBitSet *FOLLOW_children_in_node47;
static const unsigned long long FOLLOW_children_in_node47_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_STR_in_node55;
static const unsigned long long FOLLOW_STR_in_node55_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_ID_in_tag72;
static const unsigned long long FOLLOW_ID_in_tag72_data[] = { 0x00000000000001F2LL};
static ANTLRBitSet *FOLLOW_attributes_in_tag74;
static const unsigned long long FOLLOW_attributes_in_tag74_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_17_in_children93;
static const unsigned long long FOLLOW_17_in_children93_data[] = { 0x0000000000040030LL};
static ANTLRBitSet *FOLLOW_childs_in_children95;
static const unsigned long long FOLLOW_childs_in_children95_data[] = { 0x0000000000040000LL};
static ANTLRBitSet *FOLLOW_18_in_children97;
static const unsigned long long FOLLOW_18_in_children97_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_19_in_children105;
static const unsigned long long FOLLOW_19_in_children105_data[] = { 0x0000000000100030LL};
static ANTLRBitSet *FOLLOW_childs_in_children107;
static const unsigned long long FOLLOW_childs_in_children107_data[] = { 0x0000000000100000LL};
static ANTLRBitSet *FOLLOW_20_in_children109;
static const unsigned long long FOLLOW_20_in_children109_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_21_in_children117;
static const unsigned long long FOLLOW_21_in_children117_data[] = { 0x0000000000400030LL};
static ANTLRBitSet *FOLLOW_childs_in_children119;
static const unsigned long long FOLLOW_childs_in_children119_data[] = { 0x0000000000400000LL};
static ANTLRBitSet *FOLLOW_22_in_children121;
static const unsigned long long FOLLOW_22_in_children121_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_23_in_children130;
static const unsigned long long FOLLOW_23_in_children130_data[] = { 0x0000000003000030LL};
static ANTLRBitSet *FOLLOW_node_in_children132;
static const unsigned long long FOLLOW_node_in_children132_data[] = { 0x0000000003000030LL};
static ANTLRBitSet *FOLLOW_set_in_children137;
static const unsigned long long FOLLOW_set_in_children137_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_node_in_childs160;
static const unsigned long long FOLLOW_node_in_childs160_data[] = { 0x0000000000000032LL};
static ANTLRBitSet *FOLLOW_tag_in_childs163;
static const unsigned long long FOLLOW_tag_in_childs163_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_ID_in_attribute183;
static const unsigned long long FOLLOW_ID_in_attribute183_data[] = { 0x00000000000001D2LL};
static ANTLRBitSet *FOLLOW_set_in_attribute185;
static const unsigned long long FOLLOW_set_in_attribute185_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_set_in_attribute208;
static const unsigned long long FOLLOW_set_in_attribute208_data[] = { 0x0000000000000022LL};
static ANTLRBitSet *FOLLOW_ID_in_attribute224;
static const unsigned long long FOLLOW_ID_in_attribute224_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_attribute_in_attributes244;
static const unsigned long long FOLLOW_attribute_in_attributes244_data[] = { 0x0000000004000002LL};
static ANTLRBitSet *FOLLOW_26_in_attributes248;
static const unsigned long long FOLLOW_26_in_attributes248_data[] = { 0x00000000000001F0LL};
static ANTLRBitSet *FOLLOW_attribute_in_attributes250;
static const unsigned long long FOLLOW_attribute_in_attributes250_data[] = { 0x0000000004000002LL};


#pragma mark Dynamic Global Scopes

#pragma mark Dynamic Rule Scopes

#pragma mark Rule return scopes start
/* returnScope */

/* returnScope */

/* returnScope */

/* returnScope */

/* returnScope */

/* returnScope */

/* returnScope */



@implementation StruxtObjCParser  // line 637

+ (void) initialize
{
    #pragma mark Bitsets
    FOLLOW_node_in_struxt26 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_node_in_struxt26_data Count:(NSUInteger)1] retain];
    FOLLOW_EOF_in_struxt28 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_EOF_in_struxt28_data Count:(NSUInteger)1] retain];
    FOLLOW_tag_in_node45 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_tag_in_node45_data Count:(NSUInteger)1] retain];
    FOLLOW_children_in_node47 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_children_in_node47_data Count:(NSUInteger)1] retain];
    FOLLOW_STR_in_node55 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_STR_in_node55_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_tag72 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_tag72_data Count:(NSUInteger)1] retain];
    FOLLOW_attributes_in_tag74 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_attributes_in_tag74_data Count:(NSUInteger)1] retain];
    FOLLOW_17_in_children93 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_17_in_children93_data Count:(NSUInteger)1] retain];
    FOLLOW_childs_in_children95 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_childs_in_children95_data Count:(NSUInteger)1] retain];
    FOLLOW_18_in_children97 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_18_in_children97_data Count:(NSUInteger)1] retain];
    FOLLOW_19_in_children105 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_19_in_children105_data Count:(NSUInteger)1] retain];
    FOLLOW_childs_in_children107 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_childs_in_children107_data Count:(NSUInteger)1] retain];
    FOLLOW_20_in_children109 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_20_in_children109_data Count:(NSUInteger)1] retain];
    FOLLOW_21_in_children117 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_21_in_children117_data Count:(NSUInteger)1] retain];
    FOLLOW_childs_in_children119 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_childs_in_children119_data Count:(NSUInteger)1] retain];
    FOLLOW_22_in_children121 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_22_in_children121_data Count:(NSUInteger)1] retain];
    FOLLOW_23_in_children130 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_23_in_children130_data Count:(NSUInteger)1] retain];
    FOLLOW_node_in_children132 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_node_in_children132_data Count:(NSUInteger)1] retain];
    FOLLOW_set_in_children137 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_set_in_children137_data Count:(NSUInteger)1] retain];
    FOLLOW_node_in_childs160 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_node_in_childs160_data Count:(NSUInteger)1] retain];
    FOLLOW_tag_in_childs163 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_tag_in_childs163_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_attribute183 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_attribute183_data Count:(NSUInteger)1] retain];
    FOLLOW_set_in_attribute185 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_set_in_attribute185_data Count:(NSUInteger)1] retain];
    FOLLOW_set_in_attribute208 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_set_in_attribute208_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_attribute224 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_attribute224_data Count:(NSUInteger)1] retain];
    FOLLOW_attribute_in_attributes244 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_attribute_in_attributes244_data Count:(NSUInteger)1] retain];
    FOLLOW_26_in_attributes248 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_26_in_attributes248_data Count:(NSUInteger)1] retain];
    FOLLOW_attribute_in_attributes250 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_attribute_in_attributes250_data Count:(NSUInteger)1] retain];

    [ANTLRBaseRecognizer setTokenNames:[[[NSArray alloc] initWithObjects:@"<invalid>", @"<EOR>", @"<DOWN>", @"<UP>", 
 @"STR", @"ID", @"INT", @"FLOAT", @"CHAR", @"COMMENT", @"WS", @"ESC_SEQ", 
 @"STRING", @"EXPONENT", @"HEX_DIGIT", @"UNICODE_ESC", @"OCTAL_ESC", @"'{'", 
 @"'}'", @"'['", @"']'", @"'('", @"')'", @"':'", @"'.'", @"';'", @"','", nil] retain]];
}

+ (StruxtObjCParser *)newStruxtObjCParser:(id<ANTLRTokenStream>)aStream
{
    return [[StruxtObjCParser alloc] initWithTokenStream:aStream];

}

- (id) initWithTokenStream:(id<ANTLRTokenStream>)aStream
{
    if ((self = [super initWithTokenStream:aStream State:[[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:7+1] retain]]) != nil) {


        dfa6 = [DFA6 newDFA6WithRecognizer:self];

        /* start of actions-actionScope-init */
        /* start of init */
    }
    return self;
}

- (void) dealloc
{
    [dfa6 release];
    [super dealloc];
}
// start actions.actionScope.methods
// start methods()
// start rules
/*
 * $ANTLR start struxt
 * /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:7:1: struxt : node EOF ;
 */
- (void) struxt
{
    /* ruleScopeSetUp */

    @try {
        // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:8:5: ( node EOF ) // ruleBlockSingleAlt
        // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:8:7: node EOF // alt
        {
        [self pushFollow:FOLLOW_node_in_struxt26];
        [self node];
        [self popFollow];

          /* element() */
        [self match:input TokenType:EOF Follow:FOLLOW_EOF_in_struxt28];   /* element() */
         /* elements */
        }

        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }    @finally {
    }
    return ;
}
/* $ANTLR end struxt */
/*
 * $ANTLR start node
 * /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:11:1: node : ( tag children | STR );
 */
- (void) node
{
    /* ruleScopeSetUp */

    @try {
        // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:12:5: ( tag children | STR ) //ruleblock
        NSInteger alt1=2;
        NSInteger LA1_0 = [input LA:1];

        if ( (LA1_0==ID) ) {
            alt1=1;
        }
        else if ( (LA1_0==STR) ) {
            alt1=2;
        }
        else {
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:1 state:0 stream:input];
            @throw nvae;
        }
        switch (alt1) {
            case 1 : ;
                // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:12:7: tag children // alt
                {
                [self pushFollow:FOLLOW_tag_in_node45];
                [self tag];
                [self popFollow];

                  /* element() */
                [self pushFollow:FOLLOW_children_in_node47];
                [self children];
                [self popFollow];

                  /* element() */
                 /* elements */
                }
                break;
            case 2 : ;
                // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:13:7: STR // alt
                {
                [self match:input TokenType:STR Follow:FOLLOW_STR_in_node55];   /* element() */
                 /* elements */
                }
                break;

        }
        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }    @finally {
    }
    return ;
}
/* $ANTLR end node */
/*
 * $ANTLR start tag
 * /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:16:1: tag : ID ( attributes )? ;
 */
- (void) tag
{
    /* ruleScopeSetUp */

    @try {
        // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:17:5: ( ID ( attributes )? ) // ruleBlockSingleAlt
        // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:17:7: ID ( attributes )? // alt
        {
        [self match:input TokenType:ID Follow:FOLLOW_ID_in_tag72];   /* element() */
        // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:17:10: ( attributes )? // block
        NSInteger alt2=2;
        NSInteger LA2_0 = [input LA:1];

        if ( ((LA2_0>=STR && LA2_0<=CHAR)) ) {
            alt2=1;
        }
        switch (alt2) {
            case 1 : ;
                // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:17:10: attributes // alt
                {
                [self pushFollow:FOLLOW_attributes_in_tag74];
                [self attributes];
                [self popFollow];

                  /* element() */
                 /* elements */
                }
                break;

        }
          /* element() */
         /* elements */
        }

        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }    @finally {
    }
    return ;
}
/* $ANTLR end tag */
/*
 * $ANTLR start children
 * /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:20:10: fragment children : ( '{' childs '}' | '[' childs ']' | '(' childs ')' | ( ':' ( node )* )? ( '.' | ';' ) );
 */
- (void) children
{
    /* ruleScopeSetUp */

    @try {
        // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:21:5: ( '{' childs '}' | '[' childs ']' | '(' childs ')' | ( ':' ( node )* )? ( '.' | ';' ) ) //ruleblock
        NSInteger alt5=4;
        switch ([input LA:1]) {
            case 17: ;
                {
                alt5=1;
                }
                break;
            case 19: ;
                {
                alt5=2;
                }
                break;
            case 21: ;
                {
                alt5=3;
                }
                break;
            case 23: ;
            case 24: ;
            case 25: ;
                {
                alt5=4;
                }
                break;

        default: ;
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:5 state:0 stream:input];
            @throw nvae;
        }

        switch (alt5) {
            case 1 : ;
                // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:21:7: '{' childs '}' // alt
                {
                [self match:input TokenType:17 Follow:FOLLOW_17_in_children93];   /* element() */
                [self pushFollow:FOLLOW_childs_in_children95];
                [self childs];
                [self popFollow];

                  /* element() */
                [self match:input TokenType:18 Follow:FOLLOW_18_in_children97];   /* element() */
                 /* elements */
                }
                break;
            case 2 : ;
                // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:22:7: '[' childs ']' // alt
                {
                [self match:input TokenType:19 Follow:FOLLOW_19_in_children105];   /* element() */
                [self pushFollow:FOLLOW_childs_in_children107];
                [self childs];
                [self popFollow];

                  /* element() */
                [self match:input TokenType:20 Follow:FOLLOW_20_in_children109];   /* element() */
                 /* elements */
                }
                break;
            case 3 : ;
                // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:23:7: '(' childs ')' // alt
                {
                [self match:input TokenType:21 Follow:FOLLOW_21_in_children117];   /* element() */
                [self pushFollow:FOLLOW_childs_in_children119];
                [self childs];
                [self popFollow];

                  /* element() */
                [self match:input TokenType:22 Follow:FOLLOW_22_in_children121];   /* element() */
                 /* elements */
                }
                break;
            case 4 : ;
                // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:24:7: ( ':' ( node )* )? ( '.' | ';' ) // alt
                {
                // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:24:7: ( ':' ( node )* )? // block
                NSInteger alt4=2;
                NSInteger LA4_0 = [input LA:1];

                if ( (LA4_0==23) ) {
                    alt4=1;
                }
                switch (alt4) {
                    case 1 : ;
                        // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:24:8: ':' ( node )* // alt
                        {
                        [self match:input TokenType:23 Follow:FOLLOW_23_in_children130];   /* element() */
                        do {
                            NSInteger alt3=2;
                            NSInteger LA3_0 = [input LA:1];
                            if ( ((LA3_0>=STR && LA3_0<=ID)) ) {
                                alt3=1;
                            }


                            switch (alt3) {
                                case 1 : ;
                                    // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:24:12: node // alt
                                    {
                                    [self pushFollow:FOLLOW_node_in_children132];
                                    [self node];
                                    [self popFollow];

                                      /* element() */
                                     /* elements */
                                    }
                                    break;

                                default :
                                    goto loop3;
                            }
                        } while (YES);
                        loop3: ;
                          /* element() */
                         /* elements */
                        }
                        break;

                }
                  /* element() */
                if ((([input LA:1] >= 24) && ([input LA:1] <= 25))) {
                    [input consume];
                    [state setIsErrorRecovery:NO];
                } else {
                    ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
                    @throw mse;
                }
                  /* element() */
                 /* elements */
                }
                break;

        }
        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }    @finally {
    }
    return ;
}
/* $ANTLR end children */
/*
 * $ANTLR start childs
 * /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:27:10: fragment childs : ( node )* ( tag )? ;
 */
- (void) childs
{
    /* ruleScopeSetUp */

    @try {
        // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:28:5: ( ( node )* ( tag )? ) // ruleBlockSingleAlt
        // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:28:7: ( node )* ( tag )? // alt
        {
        do {
            NSInteger alt6=2;
            alt6 = [dfa6 predict:input];
            switch (alt6) {
                case 1 : ;
                    // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:28:7: node // alt
                    {
                    [self pushFollow:FOLLOW_node_in_childs160];
                    [self node];
                    [self popFollow];

                      /* element() */
                     /* elements */
                    }
                    break;

                default :
                    goto loop6;
            }
        } while (YES);
        loop6: ;
          /* element() */
        // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:28:13: ( tag )? // block
        NSInteger alt7=2;
        NSInteger LA7_0 = [input LA:1];

        if ( (LA7_0==ID) ) {
            alt7=1;
        }
        switch (alt7) {
            case 1 : ;
                // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:28:13: tag // alt
                {
                [self pushFollow:FOLLOW_tag_in_childs163];
                [self tag];
                [self popFollow];

                  /* element() */
                 /* elements */
                }
                break;

        }
          /* element() */
         /* elements */
        }

        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }    @finally {
    }
    return ;
}
/* $ANTLR end childs */
/*
 * $ANTLR start attribute
 * /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:31:10: fragment attribute : ( ID ( STR | INT | FLOAT | CHAR )? | ( STR | INT | FLOAT | CHAR ) ( ID )? );
 */
- (void) attribute
{
    /* ruleScopeSetUp */

    @try {
        // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:32:5: ( ID ( STR | INT | FLOAT | CHAR )? | ( STR | INT | FLOAT | CHAR ) ( ID )? ) //ruleblock
        NSInteger alt10=2;
        NSInteger LA10_0 = [input LA:1];

        if ( (LA10_0==ID) ) {
            alt10=1;
        }
        else if ( (LA10_0==STR||(LA10_0>=INT && LA10_0<=CHAR)) ) {
            alt10=2;
        }
        else {
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:10 state:0 stream:input];
            @throw nvae;
        }
        switch (alt10) {
            case 1 : ;
                // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:32:7: ID ( STR | INT | FLOAT | CHAR )? // alt
                {
                [self match:input TokenType:ID Follow:FOLLOW_ID_in_attribute183];   /* element() */
                // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:32:10: ( STR | INT | FLOAT | CHAR )? // block
                NSInteger alt8=2;
                NSInteger LA8_0 = [input LA:1];

                if ( (LA8_0==STR||(LA8_0>=INT && LA8_0<=CHAR)) ) {
                    alt8=1;
                }
                switch (alt8) {
                    case 1 : ;
                        // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g: // alt
                        {
                        if ([input LA:1] == STR||(([input LA:1] >= INT) && ([input LA:1] <= CHAR))) {
                            [input consume];
                            [state setIsErrorRecovery:NO];
                        } else {
                            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
                            @throw mse;
                        }
                          /* element() */
                         /* elements */
                        }
                        break;

                }
                  /* element() */
                 /* elements */
                }
                break;
            case 2 : ;
                // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:33:7: ( STR | INT | FLOAT | CHAR ) ( ID )? // alt
                {
                if ([input LA:1] == STR||(([input LA:1] >= INT) && ([input LA:1] <= CHAR))) {
                    [input consume];
                    [state setIsErrorRecovery:NO];
                } else {
                    ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
                    @throw mse;
                }
                  /* element() */
                // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:33:34: ( ID )? // block
                NSInteger alt9=2;
                NSInteger LA9_0 = [input LA:1];

                if ( (LA9_0==ID) ) {
                    alt9=1;
                }
                switch (alt9) {
                    case 1 : ;
                        // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:33:34: ID // alt
                        {
                        [self match:input TokenType:ID Follow:FOLLOW_ID_in_attribute224];   /* element() */
                         /* elements */
                        }
                        break;

                }
                  /* element() */
                 /* elements */
                }
                break;

        }
        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }    @finally {
    }
    return ;
}
/* $ANTLR end attribute */
/*
 * $ANTLR start attributes
 * /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:36:10: fragment attributes : attribute ( ',' attribute )* ;
 */
- (void) attributes
{
    /* ruleScopeSetUp */

    @try {
        // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:37:5: ( attribute ( ',' attribute )* ) // ruleBlockSingleAlt
        // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:37:7: attribute ( ',' attribute )* // alt
        {
        [self pushFollow:FOLLOW_attribute_in_attributes244];
        [self attribute];
        [self popFollow];

          /* element() */
        do {
            NSInteger alt11=2;
            NSInteger LA11_0 = [input LA:1];
            if ( (LA11_0==26) ) {
                alt11=1;
            }


            switch (alt11) {
                case 1 : ;
                    // /Users/Shared/Dropbox/workspace/projects/github.com/text-plain/struxt/struxt.parsers/src/main/antlr/StruxtObjC.g:37:19: ',' attribute // alt
                    {
                    [self match:input TokenType:26 Follow:FOLLOW_26_in_attributes248];   /* element() */
                    [self pushFollow:FOLLOW_attribute_in_attributes250];
                    [self attribute];
                    [self popFollow];

                      /* element() */
                     /* elements */
                    }
                    break;

                default :
                    goto loop11;
            }
        } while (YES);
        loop11: ;
          /* element() */
         /* elements */
        }

        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }    @finally {
    }
    return ;
}
/* $ANTLR end attributes */

@end /* end of StruxtObjCParser implementation line 692 */


/* End of code
 * =============================================================================
 */
